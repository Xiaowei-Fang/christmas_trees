<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grand Luxury Interactive Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap');
        
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #000000; touch-action: none; }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* Luxury Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #002211; }
        ::-webkit-scrollbar-thumb { background: #d4af37; border-radius: 3px; }

        .font-luxury { font-family: 'Cinzel', serif; }
        .font-artistic { font-family: 'Great Vibes', cursive; }
        .font-body { font-family: 'Playfair Display', serif; }
        .lux-shadow { text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        
        .ui-layer { position: absolute; z-index: 10; pointer-events: none; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; }
        .pointer-events-auto { pointer-events: auto; }
        
        .btn-gold {
            background: linear-gradient(to bottom, #FFD700, #B8860B);
            color: #001a0f;
            border: 2px solid #FFF8DC;
            box-shadow: 0 0 15px rgba(255,215,0,0.5);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-gold:active { transform: scale(0.95); }
        
        .glass-panel {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
    </style>
    <!-- Import Three.js via ES Modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="ui-layer">
        <!-- Header -->
        <div class="p-6 flex flex-col items-center text-center mt-4 relative w-full pointer-events-auto">
            <h1 class="text-6xl md:text-8xl text-[#FFD700] font-artistic drop-shadow-[0_0_15px_rgba(255,215,0,0.8)] mb-2" style="text-shadow: 0 0 20px #ff0000, 0 0 40px #FFD700;">
                Merry Christmas
            </h1>
            <p class="text-[#E5E4E2] font-body text-xs md:text-sm tracking-[0.2em] opacity-80 uppercase mt-2">
                Created by Xiaowei
            </p>
        </div>

        <!-- Controls -->
        <div class="p-6 mb-4 flex flex-col items-center gap-4 pointer-events-auto w-full">
            <button id="toggle-mode-btn" class="btn-gold font-luxury font-bold py-3 px-10 rounded-sm text-sm md:text-base uppercase tracking-wider">
                UNLEASH CHAOS
            </button>

            <div class="glass-panel p-2 rounded-lg flex items-center gap-3">
                <button id="add-photo-btn" class="px-4 py-2 bg-[#004225] text-[#FFD700] border border-[#FFD700] rounded hover:bg-[#005c35] font-luxury text-xs md:text-sm transition-colors">
                    + PHOTO
                </button>
                <span id="photo-count" class="text-[#FFD700] font-bold font-luxury text-sm">0 / 8</span>
                <button id="remove-photo-btn" class="px-4 py-2 bg-[#8B0000] text-[#FFD700] border border-[#FFD700] rounded hover:bg-[#a00000] font-luxury text-xs md:text-sm transition-colors">
                    - REMOVE
                </button>
            </div>
            <input type="file" id="file-input" accept="image/*" style="display: none;">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- CONSTANTS ---
        const CONFIG = {
            colors: {
                emerald: new THREE.Color('#004225'),
                gold: new THREE.Color('#FFD700'),
                red: new THREE.Color('#D40000'), 
                silver: new THREE.Color('#E5E4E2'),
                green: new THREE.Color('#006400'),
                blue: new THREE.Color('#1E90FF'),
                purple: new THREE.Color('#8A2BE2')
            },
            tree: { height: 10, radius: 3.8, chaosRadius: 8, needleCount: 3000, ornamentCount: 120 },
            photos: { max: 8 }
        };

        // --- STATE ---
        const state = {
            mode: 'FORMED', // Start in FORMED state
            progress: 1,    // Start fully formed
            photos: [],    // Array of groups
            time: 0
        };

        // --- UTILS ---
        const getRandomSpherePoint = (radius) => {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = Math.cbrt(Math.random()) * radius;
            const sinPhi = Math.sin(phi);
            return new THREE.Vector3(r * sinPhi * Math.cos(theta), r * sinPhi * Math.sin(theta), r * Math.cos(phi));
        };

        const getConePoint = (t, total, height, maxRadius, offset = 0) => {
            const y = (t / total) * height - (height / 2);
            const progress = 1 - (t / total);
            const r = progress * maxRadius;
            const angle = t * 0.5 + offset;
            return new THREE.Vector3(r * Math.cos(angle), y + 1, r * Math.sin(angle));
        };

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Pure black background
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // Black fog
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        
        // ACESFilmicToneMapping for cinematic light
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8; // Slightly darkened exposure
        
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.minDistance = 8;
        controls.maxDistance = 25;
        controls.maxPolarAngle = Math.PI / 1.5;
        controls.autoRotate = false;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.3);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xFFD700, 1000); 
        spotLight.position.set(10, 20, 10);
        spotLight.angle = 0.5;
        spotLight.penumbra = 1;
        spotLight.castShadow = true;
        scene.add(spotLight);

        // Point lights
        const pointLight1 = new THREE.PointLight(0xFFFFFF, 20, 20);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xFFFDD0, 20, 20);
        pointLight2.position.set(-5, 2, -5);
        scene.add(pointLight2);

        // --- ENVIRONMENT (STARS) ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 100;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        
        const starMat = new THREE.PointsMaterial({color: 0x888888, size: 0.1, transparent: true, opacity: 0.3});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- TREE COMPONENTS GROUP ---
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // --- FOLIAGE SYSTEM ---
        const foliageGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.tree.needleCount * 3);
        const chaosPos = new Float32Array(CONFIG.tree.needleCount * 3);
        const targetPos = new Float32Array(CONFIG.tree.needleCount * 3);

        for (let i = 0; i < CONFIG.tree.needleCount; i++) {
            // Chaos
            const c = getRandomSpherePoint(CONFIG.tree.chaosRadius);
            chaosPos[i*3] = c.x; chaosPos[i*3+1] = c.y; chaosPos[i*3+2] = c.z;
            
            // Target (Cone)
            const h = Math.random() * CONFIG.tree.height;
            const rMax = ((CONFIG.tree.height - h) / CONFIG.tree.height) * CONFIG.tree.radius;
            const r = Math.sqrt(Math.random()) * rMax;
            const theta = Math.random() * Math.PI * 2;
            const y = h - CONFIG.tree.height / 2 + 1;
            
            targetPos[i*3] = r * Math.cos(theta);
            targetPos[i*3+1] = y;
            targetPos[i*3+2] = r * Math.sin(theta);

            positions[i*3] = 0; positions[i*3+1] = 0; positions[i*3+2] = 0;
        }

        foliageGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        foliageGeo.setAttribute('aChaos', new THREE.BufferAttribute(chaosPos, 3));
        foliageGeo.setAttribute('aTarget', new THREE.BufferAttribute(targetPos, 3));

        const foliageUniforms = {
            uTime: { value: 0 },
            uProgress: { value: 1.0 },
            uColor1: { value: CONFIG.colors.emerald },
            uColor2: { value: CONFIG.colors.gold }
        };

        const foliageMat = new THREE.ShaderMaterial({
            uniforms: foliageUniforms,
            vertexShader: `
                uniform float uTime;
                uniform float uProgress;
                attribute vec3 aChaos;
                attribute vec3 aTarget;
                varying float vAlpha;
                
                float ease(float t) { return t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0; }

                void main() {
                    float t = ease(uProgress);
                    vec3 pos = mix(aChaos, aTarget, t);
                    // Gentle wind
                    pos.x += sin(uTime * 2.0 + pos.y) * 0.05 * uProgress;
                    float sparkle = sin(uTime * 3.0 + pos.x * 5.0) * 0.5 + 0.5;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // Increased point size to avoid pixelated look on lights
                    gl_PointSize = (8.0 * sparkle + 6.0) * (10.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                    vAlpha = 0.8 + sparkle * 0.2;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                varying float vAlpha;
                void main() {
                    vec2 center = gl_PointCoord - 0.5;
                    if (length(center) > 0.5) discard;
                    
                    // Soft glow
                    float d = length(center) * 2.0;
                    float glow = 1.0 - d;
                    glow = pow(glow, 2.0); // Sharper falloff

                    vec3 color = mix(uColor1, uColor2, 1.0 - d);
                    if(d < 0.3) color = mix(color, vec3(1.0, 1.0, 0.8), 0.5);

                    gl_FragColor = vec4(color, vAlpha * glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const foliage = new THREE.Points(foliageGeo, foliageMat);
        treeGroup.add(foliage);
        
        // --- ORNAMENTS SYSTEM ---
        const ornamentGeo = new THREE.SphereGeometry(0.18, 24, 24); 
        const ornamentMat = new THREE.MeshStandardMaterial({ 
            roughness: 0.2, 
            metalness: 0.9,
            envMapIntensity: 1.0
        });
        const ornaments = new THREE.InstancedMesh(ornamentGeo, ornamentMat, CONFIG.tree.ornamentCount);
        
        const ornamentData = [];
        const dummy = new THREE.Object3D();
        const availableColors = [
            CONFIG.colors.red, 
            CONFIG.colors.gold, 
            CONFIG.colors.green, 
            CONFIG.colors.blue, 
            CONFIG.colors.purple,
            CONFIG.colors.silver
        ];

        for (let i = 0; i < CONFIG.tree.ornamentCount; i++) {
            const chaos = getRandomSpherePoint(CONFIG.tree.chaosRadius);
            const target = getConePoint(i, CONFIG.tree.ornamentCount, CONFIG.tree.height, CONFIG.tree.radius, i * 0.5);
            
            const scale = Math.random() * 0.8 + 0.8;
            const color = availableColors[i % availableColors.length];
            ornaments.setColorAt(i, color);
            
            ornamentData.push({
                id: i,
                chaos,
                target,
                scale,
                color: color
            });
            
            dummy.position.copy(target);
            dummy.updateMatrix();
            ornaments.setMatrixAt(i, dummy.matrix);
        }
        ornaments.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        treeGroup.add(ornaments);

        // --- RIBBON (TINSEL) ---
        const ribbonCurvePoints = [];
        const ribbonLoops = 12; // Increased loops for better look
        const ribbonHeight = CONFIG.tree.height;
        for(let i=0; i<=200; i++) { // More points for smoothness
            const t = i / 200;
            const angle = t * Math.PI * 2 * ribbonLoops;
            const y = (1 - t) * ribbonHeight - ribbonHeight/2 + 0.5;
            const r = t * (CONFIG.tree.radius + 0.2); // Slightly outside tree
            ribbonCurvePoints.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
        }
        const ribbonCurve = new THREE.CatmullRomCurve3(ribbonCurvePoints);
        // Thinner radius (0.02)
        const ribbonGeo = new THREE.TubeGeometry(ribbonCurve, 200, 0.02, 8, false);
        const ribbonMat = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            metalness: 0.9,
            roughness: 0.3,
            emissive: 0xaa7700,
            emissiveIntensity: 0.2 // Reduced emissive to prevent blown out yellow
        });
        const ribbon = new THREE.Mesh(ribbonGeo, ribbonMat);
        treeGroup.add(ribbon);

        // --- TOP STAR ---
        const starTopperGeo = new THREE.OctahedronGeometry(0.8, 0);
        const starTopperMat = new THREE.MeshStandardMaterial({
            color: 0xFFFDD0,
            emissive: 0xFFFDD0,
            emissiveIntensity: 1.0,
            metalness: 0.5,
            roughness: 0.0
        });
        const starTopper = new THREE.Mesh(starTopperGeo, starTopperMat);
        starTopper.position.set(0, CONFIG.tree.height/2 + 0.8, 0);
        treeGroup.add(starTopper);

        // --- PHOTO SYSTEM ---
        const photoGroup = new THREE.Group(); // Photos are in scene root, not treeGroup
        const photoSlots = [];
        
        // Calculate slots (positions only)
        for(let i=0; i<CONFIG.photos.max; i++) {
            const t = i / (CONFIG.photos.max - 1);
            const y = THREE.MathUtils.lerp(-CONFIG.tree.height * 0.3, CONFIG.tree.height * 0.3, t);
            const hTop = (CONFIG.tree.height / 2) - y;
            const r = (hTop / CONFIG.tree.height) * (CONFIG.tree.radius * 1.1);
            const angle = i * (Math.PI * 0.8);
            const x = r * Math.cos(angle);
            const z = r * Math.sin(angle);
            photoSlots.push({
                pos: new THREE.Vector3(x, y + 1.5, z),
                rot: new THREE.Euler(0, -angle, 0),
                angleOffset: angle // Store original angle for slot tracking
            });
        }

        // Gold Frame Material
        const goldMat = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, 
            metalness: 1.0, 
            roughness: 0.15,
            emissive: 0xaa7700, 
            emissiveIntensity: 0.4 
        });

        function addPhoto(url) {
            if(state.photos.length >= CONFIG.photos.max) return;

            const img = new Image();
            img.src = url;
            img.onload = () => {
                const index = state.photos.length;
                const slot = photoSlots[index];
                const chaosP = getRandomSpherePoint(CONFIG.tree.chaosRadius * 0.3);

                // Aspect Ratio Calculation
                const aspect = img.width / img.height;
                let imgW, imgH;

                // Logic: constrain max dimension to avoid huge photos
                if (aspect > 1) {
                    // Landscape
                    imgW = 1.8; 
                    imgH = 1.8 / aspect;
                } else {
                    // Portrait or Square
                    imgH = 1.6;
                    imgW = 1.6 * aspect;
                }

                // Texture
                const tex = new THREE.Texture(img);
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.needsUpdate = true;
                
                // --- CREATE PHOTO OBJECT (Frame + Picture) ---
                const group = new THREE.Group();

                // 1. Frame Background (Gold Box)
                const borderSize = 0.12;
                const frameGeo = new THREE.BoxGeometry(imgW + borderSize, imgH + borderSize, 0.05);
                const frameMesh = new THREE.Mesh(frameGeo, goldMat);
                frameMesh.castShadow = true;
                frameMesh.receiveShadow = true;
                group.add(frameMesh);

                // 2. Picture (Plane)
                const photoGeo = new THREE.PlaneGeometry(imgW, imgH);
                const photoMat = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    color: 0xffffff,
                    side: THREE.FrontSide
                });
                const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                // Position slightly in front of frame to avoid z-fighting and give depth
                photoMesh.position.z = 0.03; 
                group.add(photoMesh);

                group.userData = { 
                    isPhoto: true, 
                    index: index, 
                    chaosPos: chaosP, 
                    slotPos: slot.pos,
                    angleOffset: slot.angleOffset,
                    active: false,
                    baseScale: new THREE.Vector3(1, 1, 1) // Geometry is intrinsically sized
                };
                
                // Start formed
                group.position.copy(slot.pos);
                
                photoGroup.add(group);
                state.photos.push(group);
                updateUI();
            };
        }

        function removePhoto() {
            if(state.photos.length === 0) return;
            const group = state.photos.pop();
            photoGroup.remove(group);
            
            // Cleanup
            group.children.forEach(child => {
                if(child.geometry) child.geometry.dispose();
                if(child.material) {
                    if(child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            });

            updateUI();
        }

        scene.add(photoGroup);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Toned down Bloom
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.4, 0.2, 0.85);
        composer.addPass(bloomPass);
        
        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // Recursive intersect to hit children meshes in Groups
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            
            if (intersects.length > 0) {
                // Traverse up to find the group with userData
                let target = intersects[0].object;
                while(target && !target.userData.isPhoto && target.parent) {
                    target = target.parent;
                }
                
                if(target && target.userData.isPhoto) {
                    target.userData.active = !target.userData.active;
                }
            }
        });

        // --- ANIMATION LOOP ---
        const Y_AXIS = new THREE.Vector3(0, 1, 0);

        function animate() {
            requestAnimationFrame(animate);
            state.time += 0.01;

            foliageUniforms.uTime.value = state.time;
            
            const targetProgress = state.mode === 'FORMED' ? 1.0 : 0.0;
            state.progress = THREE.MathUtils.lerp(state.progress, targetProgress, 0.02);
            foliageUniforms.uProgress.value = state.progress;

            // Rotate Tree
            treeGroup.rotation.y += 0.003;
            
            // Rotate Star
            starTopper.rotation.y -= 0.01;
            starTopper.rotation.z = Math.sin(state.time) * 0.1;

            // Update Ornaments Color & Pos
            const isFormed = state.mode === 'FORMED';

            for (let i = 0; i < CONFIG.tree.ornamentCount; i++) {
                const d = ornamentData[i];
                let t = state.progress;
                const pos = new THREE.Vector3().lerpVectors(d.chaos, d.target, t);
                dummy.position.copy(pos);
                dummy.rotation.set(t * Math.PI * 2 + d.id, t * Math.PI + d.id, 0);
                
                const s = d.scale * (0.8 + 0.2 * Math.sin(t * Math.PI));
                dummy.scale.setScalar(s);
                dummy.updateMatrix();
                
                ornaments.setMatrixAt(i, dummy.matrix);
            }
            ornaments.instanceMatrix.needsUpdate = true;
            if(ornaments.instanceColor) ornaments.instanceColor.needsUpdate = true;

            // Update Photos
            state.photos.forEach(group => {
                const ud = group.userData;
                
                // 1. Calculate Position
                const rigidPos = ud.slotPos.clone().applyAxisAngle(Y_AXIS, treeGroup.rotation.y);
                const targetPos = new THREE.Vector3().lerpVectors(ud.chaosPos, rigidPos, state.progress);
                group.position.lerp(targetPos, 0.05);
                
                // 2. Rotation Logic (Face Screen + Tilt)
                group.lookAt(camera.position);
                
                const screenPos = group.position.clone().project(camera);
                const tiltAmount = screenPos.x * 0.6; 
                group.rotateY(tiltAmount);

                // 3. Scale Logic
                let sX = ud.baseScale.x;
                let sY = ud.baseScale.y;
                let sZ = ud.baseScale.z;

                if (ud.active) {
                    const zoomFactor = 2.5; // Zoom in
                    sX *= zoomFactor; sY *= zoomFactor; sZ *= zoomFactor;
                } else if (state.mode === 'CHAOS') {
                    const chaosFactor = 1.2;
                    sX *= chaosFactor; sY *= chaosFactor; sZ *= chaosFactor;
                }

                group.scale.lerp(new THREE.Vector3(sX, sY, sZ), 0.1);
            });

            // Ribbon visibility fade
            ribbonMat.opacity = state.progress;
            ribbonMat.transparent = true;

            composer.render();
        }

        // --- UI LOGIC ---
        const modeBtn = document.getElementById('toggle-mode-btn');
        modeBtn.addEventListener('click', () => {
            state.mode = state.mode === 'CHAOS' ? 'FORMED' : 'CHAOS';
            modeBtn.innerText = state.mode === 'CHAOS' ? 'ASSEMBLE TREE' : 'UNLEASH CHAOS';
        });

        const fileInput = document.getElementById('file-input');
        document.getElementById('add-photo-btn').addEventListener('click', () => {
            if(state.photos.length < CONFIG.photos.max) {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = function(evt) {
                    addPhoto(evt.target.result);
                };
                reader.readAsDataURL(file);
            }
            e.target.value = '';
        });

        document.getElementById('remove-photo-btn').addEventListener('click', removePhoto);

        function updateUI() {
            document.getElementById('photo-count').innerText = `${state.photos.length} / ${CONFIG.photos.max}`;
        }

        // --- INIT ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>